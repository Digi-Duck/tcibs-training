<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>編輯</title>

    <style>
        *{
            /* margin: 5px; */
            font-size: 25px;
            font-weight: 600;
            user-select: none;
        }
        input{
            width: 100px;
        }
        button{
            margin: 5px;
        }
        body{
            width: 100%;
            height: 100vh;
            background-color: #565656;
            margin: 0px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        label{
            color: #ffffff;
        }  
        .top{
            width: 90%;
            display: flex;
        }
        main{
            width: 90%;
            height: 80vh;
            /* background-color: #ffffff; */
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px;
        }
        .left,.right{
            width: 15%;
            height: 100%;
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            justify-content: space-around;
            align-content: center;
            background-color: #ffffff;
        }
        canvas{
            /* width: 67%;
            height: 100%; */
            background-color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="top">
        <button>新增專案</button>
        <button class="restore">復原</button>
        <button class="redo">重做</button>
        <button>儲存圖片</button>
    </div>
    <main>
        <div class="left">
            <button>選取</button>
            <button class="pan">筆刷</button>
            <input type="number" id="size" value="50">
            <button class="fill">油漆桶</button>
            <!-- <button>調色盤</button> -->
            <input type="color" name="" id="color">
            <button>樣章</button>
            <button>儲存為樣章</button>
            <button>上傳圖片</button>
        </div>
        <canvas></canvas>
        <div class="right"></div>
    </main>

    <script>
        const canvas = document.querySelector('canvas');
        const ctx = canvas.getContext('2d');
        const color = document.querySelector('#color');
        const size = document.querySelector('#size');
        const restoreBtn = document.querySelector('.restore');
        const redo = document.querySelector('.redo');
        const fillBtn = document.querySelector('.fill');
        const panBtn = document.querySelector('.pan');
        canvas.width = 1000;
        canvas.height = 685;
        let restore = [ctx.getImageData(0,0,canvas.width,canvas.height)];
        let pan = true;
        let draw,fill = false;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.save();
        let i = 1;
        let colorRGB = [];
        let now,start,fillData,fillcolor;

        let img = new Image();
        img.src = './3075977.png';

        canvas.addEventListener('mousedown', function(e){
            if (pan) {                
                ctx.lineWidth = size.value;
                ctx.strokeStyle = color.value;
                ctx.beginPath(); 
                ctx.moveTo(e.offsetX, e.offsetY);
                ctx.drawImage(img,e.offsetX - size.value/2, e.offsetY - size.value/2, size.value, size.value); 
                ctx.stroke();
                draw = true;
            }
        });
        canvas.addEventListener('mousemove',(e)=>{
            if (draw) {                
                // ctx.lineTo(e.offsetX, e.offsetY);
                ctx.drawImage(img,e.offsetX - size.value/2, e.offsetY - size.value/2, size.value, size.value); 
                ctx.stroke();
            }
        });
        document.body.addEventListener('mouseup', function(){      
            if(draw){
                draw = false;
                restore[i] = ctx.getImageData(0, 0, canvas.width, canvas.height);
                i++;
            }
        }) 
        // canvas.addEventListener('mouseout', function(){             
        //     if (draw) {
        //         restore[i] = ctx.getImageData(0, 0, canvas.width, canvas.height);
        //         i++;
        //         draw = false;
        //     }
        // }) 
        canvas.addEventListener('click',(e)=>{
            RGB(color.value)
            if (colorRGB[0] === ctx.getImageData(e.offsetX, e.offsetY, 1, 1).data[0] && colorRGB[1] === ctx.getImageData(e.offsetX, e.offsetY, 1, 1).data[1] && colorRGB[2] === ctx.getImageData(e.offsetX, e.offsetY, 1, 1).data[2] && 255 === ctx.getImageData(e.offsetX, e.offsetY, 1, 1).data[3]) {
                fillcolor = true;
            }else{
                fillcolor = false;
            }
            console.log(fillcolor);
            if (fill && !fillcolor ) {
                floodFill(ctx, e.offsetX, e.offsetY, '0xff'+color.value.substr(5,2)+color.value.substr(3,2)+ color.value.substr(1,2));
                restore[i] = ctx.getImageData(0, 0, canvas.width, canvas.height);
                i++;
            }
        })

        restoreBtn.addEventListener('click',()=>{
            if (i > 1) {
                ctx.putImageData(restore[i - 2], 0, 0);
                i--;
            }
        })

        redo.addEventListener('click',()=>{
            if (i < restore.length) {
                ctx.putImageData(restore[i], 0, 0);
                i++;
            }
        })

        fillBtn.addEventListener('click',()=>{
            pan = false;
            fill = true;
        })
        panBtn.addEventListener('click',()=>{
            pan = true;
            fill = false;
        })

        function RGB(x) {
            colorRGB[0] = parseInt(x.substr(1, 2), 16);
            colorRGB[1] = parseInt(x.substr(3, 2), 16);
            colorRGB[2] = parseInt(x.substr(5, 2), 16);
        }

        function getPixel(pixelData, x, y) {
            if (x < 0 || y < 0 || x >= pixelData.width || y >= pixelData.height) {
                return -1;  // impossible color
            } else {
                return pixelData.data[y * pixelData.width + x];
            }
        }

        function floodFill(ctx, x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const pixelData = {
                width: canvas.width,
                height: canvas.height,
                data: new Uint32Array(imageData.data.buffer),
            };
            
            const targetColor = getPixel(pixelData, x, y);
            
            if (targetColor !== fillColor) {
                const spansToCheck = [];
                
                function addSpan(left, right, y, direction) {
                    spansToCheck.push({left, right, y, direction});
                }
                
                function checkSpan(left, right, y, direction) {
                    let inSpan = false;
                    let start;
                    let x;
                    for (x = left; x < right; ++x) {
                        const color = getPixel(pixelData, x, y);
                        if (color === targetColor) {
                        if (!inSpan) {
                            inSpan = true;
                            start = x;
                        }
                        } else {
                        if (inSpan) {
                            inSpan = false;
                            addSpan(start, x - 1, y, direction);
                        }
                        }
                    }
                    if (inSpan) {
                        inSpan = false;
                        addSpan(start, x - 1, y, direction);
                    }
                }
                
                addSpan(x, x, y, 0);
                
                while (spansToCheck.length > 0) {
                    const {left, right, y, direction} = spansToCheck.pop();
                    
                    // do left until we hit something, while we do this check above and below and add
                    let l = left;
                    let r = right;
                    while (true) {
                        l--;
                        const color = getPixel(pixelData, l, y);
                        if (color !== targetColor) {
                        break;
                        }
                    }
                    l++;
                    
                    while (true) {
                        r++;
                        const color = getPixel(pixelData, r, y);
                        if (color !== targetColor) {
                        break;
                        }
                    }
                    // r++;
                
                    const lineOffset = y * pixelData.width;
                    pixelData.data.fill(fillColor, lineOffset + l, lineOffset + r);
                    
                    if (direction <= 0) {
                        checkSpan(l, r, y - 1, -1);
                    } else {
                        checkSpan(l, left, y - 1, -1);
                        checkSpan(right, r, y - 1, -1);
                    }
                    
                    if (direction >= 0) {
                        checkSpan(l, r, y + 1, +1);
                    } else {
                        checkSpan(l, left, y + 1, +1);
                        checkSpan(right, r, y + 1, +1);
                    }     
                }
                // put the data back
                ctx.putImageData(imageData, 0, 0);
            }
        }
    </script>
</body>
</html>